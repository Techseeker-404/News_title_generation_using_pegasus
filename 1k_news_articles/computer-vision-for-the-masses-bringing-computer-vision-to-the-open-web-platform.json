{"Author": "Sajjad Taheri, PhD Candidate, Alexeandru Nicolau and Alexeander Vedienbaum, Professors of Computer Science, University of California, Irvine; Ningxin Hu, Senior Staff Engineer, and Mohammad Reza Haghighat, Senior Principal Engineer, Intel Corporation\u00a0", "Date": "05.31.2018", "Keywords": "", "Article": "  The Web is the world\u00e2\u0080\u0099s most universal compute platform and the foundation for the digital economy. Since its birth in early 1990s, Web capabilities have been increasing in both quantity and quality. But in spite of all the progress, computer vision isn\u00e2\u0080\u0099t yet mainstream on the Web. The reasons include:  The lack of sufficient performance of JavaScript* , the standard language of the Web The lack of camera support \u00c2\u00a0in the standard Web APIs The lack of comprehensive \u00c2\u00a0computer vision libraries  These problems are about to get solved\u00e2\u0080\u0095resulting in the potential for a more immersive and perceptual Web with transformational effects including online shopping, education, and entertainment, among others. Over the last decade, the tremendous improvements in JavaScript performance, plus the recent emergence of WebAssembly*, close the Web performance gap with native computing. And the HTML5 WebRTC* API has brought camera support to the Open Web Platform*. Even so, a comprehensive library of computer vision algorithms for the Web was still lacking. This article outlines a solution for the last piece of the problem by bringing OpenCV* to the Open Web Platform. OpenCV is the most popular computer vision library, with a comprehensive set of vision functions and a large developer community. It\u00e2\u0080\u0099s implemented in C++ and, up until now, was not available in Web browsers without the help of unpopular native plugins. [Sponsored: Learn more about Bluetooth 5, Refined for the IoT] We\u00e2\u0080\u0099ll show how to leverage OpenCV efficiency, completeness, API maturity, and its community\u00e2\u0080\u0099s collective knowledge to bring hundreds of OpenCV functions to the Open Web Platform. It\u00e2\u0080\u0099s provided in a format that\u00e2\u0080\u0099s easy for JavaScript engines to optimize and has an API that\u00e2\u0080\u0099s easy for Web programmers to adopt and use to develop applications. On top of that, we\u00e2\u0080\u0099ll show how to port OpenCV parallel implementations that target single instruction, multiple data (SIMD) units and multiple processor cores to equivalent Web primitives\u00e2\u0080\u0095providing the high performance required for real-time and interactive use cases. The Open Web Platform  The Open Web Platform is the most universal computing platform, with billions of connected devices. Its popularity in online commerce, entertainment, science, and education has grown exponentially\u00e2\u0080\u0095as has the amount of multimedia content on the Web. Despite this, computer vision processing on Web browsers hasn\u00e2\u0080\u0099t been a common practice. The lack of client-side vision processing is due to several limitations:  A lack of standard Web APIs \u00c2\u00a0to access and transfer multimedia content Inferior JavaScript \u00c2\u00a0performance Lack of a comprehensive \u00c2\u00a0computer vision library to develop apps  The approach we outline here, along with other recent developments on the Web front, will address those limitations and empower the Web with proper computer vision capabilities. Adding Camera Support and Plugin-Free Multimedia Delivery  HTML5 introduced several Web APIs to capture, transfer, and present multimedia content in browsers without the need for third-party plugins. One of these, Web Real-Time Communication* (WebRTC*), allows acquisition and peer-to-peer transportation of multimedia content and video elements to display videos. Recently, the immersive Web with access to virtual reality (VR) and augmented reality (AR) content has begun delivering new, engaging user experiences. Improved JavaScript* Performance  JavaScript is the dominant language of the Web. Because it\u00e2\u0080\u0099s a scripting language with dynamic typing, its performance is inferior to that of native languages such as C++. Multimedia processing often involves complex algorithms and massive amounts of computation. With client-side technologies such as just-in-time (JIT) compilation, and with the introduction of WebAssembly* (WASM*), a portable, binary format for the Web, Web clients can reach a near-native performance with JavaScript and handle more demanding tasks. A Comprehensive Computer Vision Library  Although there are several computer vision libraries developed in native languages such C++, they can\u00e2\u0080\u0099t be used in browsers without relying on unpopular browser extensions, which pose security and portability issues. There have been a few efforts to develop computer vision libraries in JavaScript, but these are limited to select categories of vision functions. Expanding those efforts with new algorithms, and optimizing the implementation, are challenging tasks. Previous work lacked either functionality, performance, or portability. As an alternative approach, we take advantage of an existing comprehensive computer vision library developed in C++ (i.e., OpenCV) and make it work on the Web. This approach works great on the Web for several reasons:  It provides \u00c2\u00a0an expansive set of functions with optimized implementation. It performs \u00c2\u00a0more efficiently than normal JavaScript implementations, and performance will further improve through parallelism. Developers can access \u00c2\u00a0a large collection of existing resources such as tutorials and examples.  OpenCV.js*  OpenCV1 \u00c2\u00a0is the de facto library for computer vision development. It\u00e2\u0080\u0099s an open-source library that started at Intel Labs back in 2000. OpenCV is very comprehensive and has been implemented as a set of modules\u00c2\u00a0(Figure 1) . It offers a large number of primitive kernels and vision applications, ranging from image processing, object detection, and tracking to machine learning and deep neural networks (DNN). OpenCV provides efficient implementations for parallel hardware such as multicore processors with vector units. We translate many OpenCV functionalities into JavaScript and refer to it as OpenCV.js.   Figure 1 \u00e2\u0080\u0093 OpenCV implemented as a collection of modules   Table 1 \u00c2\u00a0categorizes and lists the functions currently included in OpenCV.js. It omits several OpenCV modules, for two reasons:  Not all of OpenCV\u00e2\u0080\u0099s offerings are suitable for the Web.  For instance, the high-level GUI and I/O module (highgui )\u00e2\u0080\u0095which provides functions to access media devices such as cameras and graphical user interfaces\u00e2\u0080\u0095is platform-dependent and can\u00e2\u0080\u0099t be compiled to the Web. Those functions, however, have alternatives using HTML5 primitives, which are provided by a JavaScript module (utils.js ). This works, for instance, to access files hosted on the Web and media devices through getUserMedia and to display graphics using HTML Canvas*. Some of the OpenCV functions are only used in certain application domains that aren\u00e2\u0080\u0099t common in typical Web applications.  For instance, the camera calibration module (calib3d ) is often used in robotics. To reduce the size of the generated library for general use cases, based on OpenCV community feedback, we have identified the least commonly used functions from OpenCV and excluded them from the JavaScript version of the library.  Table 1. OpenCV.js provided functionalities     Because there are still many functions that might be useful for special use cases, we\u00e2\u0080\u0099ve provided a way to build the library with user-selected functions. Translating OpenCV to JavaScript* and WebAssembly*  The emergence of Emscripten*2 , an LLVM-based source-to-source compiler developed by Mozilla, has made it possible to port many programs and libraries developed in C++ to the Web. Originally, Emscripten targets a typed subset of JavaScript called asm.js that, because of its simplicity, allows JavaScript engines to perform extra levels of optimization. In fact, it\u00e2\u0080\u0099s even possible to compile asm.js functions before execution. While performance is impressive, parsing and compiling large JavaScript files could become a bottleneck, especially for mobile devices with weaker processors. This was one of the main motivations for development of WASM3 . WASM is a portable size- and load-time-efficient binary format designed as a target for Web compilation. We used Emscripten to compile OpenCV source code into both asm.js and WASM. They offer the same functionality and can be used interchangeably. During compilation with Emscripten, the C++ high-level language information such as class and function identifiers are replaced with mangled names. Because it\u00e2\u0080\u0099s almost impossible to develop programs through mangled names, we provide binding information of different OpenCV entities such as functions and classes and expose them to JavaScript. This enables the library to have a similar interface to normal OpenCV, with which many programmers are already familiar. Because OpenCV is large, and grows continuously through new contributions, continuously updating the port by hand is impractical. So we developed a semi-automated approach that takes care of the tedious parts of the translation process while allowing expert insights that can enable high-quality, efficient code production. Figure 2 \u00c2\u00a0lists the steps involved in converting OpenCV C++ code to JavaScript. First, OpenCV source code is configured to disable components and implementations that are platform-specific, or are not optimized for the Web. Next, information about classes and functions that should be exported to JavaScript will be extracted from OpenCV source code. We use a white list of OpenCV classes and functions that should be included in the final JavaScript build. It\u00e2\u0080\u0099s possible to update the list before building to include or exclude OpenCV modules and/or functions. For efficiency, binding information for the OpenCV core module, which includes the OpenCV main data structure (i.e.,\u00c2\u00a0cv::Mat ), is manually provided. By using the binding information and function white list, we generate a glue code that maps JavaScript symbols to C++ symbols and compiles it with Emscripten along with the rest of the OpenCV library into JavaScript. The output of this process will be a JavaScript file (OpenCV.js) that serves as the library interface along with a WASM or asm.js file that implements OpenCV functions.\u00c2\u00a0 utils.js , which includes GUI, I/O, and utility functions, is also linked with OpenCV.js.   Figure 2 \u00e2\u0080\u0093 Generating OpenCV.js   Using OpenCV.js in Web Applications  Let\u00e2\u0080\u0099s explore how to use OpenCV.js to develop Web applications.\u00c2\u00a0Figure 3 \u00c2\u00a0shows an overview of OpenCV.js and its interaction with Web applications. Web applications will use the OpenCV.js API to access the functions as listed in Table 1. While the vision functions from OpenCV are compiled either into WASM or asm.js, we have developed a JavaScript module that provides GUI features and media capture. OpenCV.js utilizes standard Web APIs, such as Web workers and SIMD.js, to achieve high performance, and Canvas and WebRTC* to provide media and GUI capabilities. The OpenCV.js API is inspired by the OpenCV C++ API and shares many similarities with it. For instance, C++ functions are exported to JavaScript with the same name and signature. Function overloading and default parameters are also supported in the JavaScript version. This makes migration to JavaScript easier for users who are already familiar with OpenCV development in C++. Although OpenCV C++ classes are ported to JavaScript objects with the same member functions and properties, basic data types are different between the two versions.\u00c2\u00a0Table 2 \u00c2\u00a0shows equivalent JavaScript data types for basic C++ data types. JavaScript engines use Garbage Collector (GC) to manage program memory. However, GC activity has a negative impact on performance so OpenCV.js uses static memory management. Programmers are responsible for freeing OpenCV.js objects when they are no longer being used. Because manual memory management is tedious, we\u00e2\u0080\u0099ve used JavaScript types for primitive OpenCV types such as\u00c2\u00a0cv::Point .\u00c2\u00a0All\u00c2\u00a0std::vectors \u00c2\u00a0are translated into JavaScript arrays, except for vectors of\u00c2\u00a0cv::Mat . This is particularly helpful, because by removing the vector, it will remove all the\u00c2\u00a0cv::Mat \u00c2\u00a0elements.   Figure 3 \u00e2\u0080\u0093 OpenCV.js components and its interaction with applications and web APIs   Table 2. Exported JavaScript types for basic C++ types     We\u00e2\u0080\u0099ll present several examples to demonstrate various computer vision tasks using OpenCV.js. All of these examples work on top of a simple HTML Web page. We only present the logic part of the programs that deal with the OpenCV.js API. Figure 4 \u00c2\u00a0shows how to apply the Canny algorithm to find the edges in an image. Input images will be loaded from an HTML Canvas. For this purpose, we\u00e2\u0080\u0099ve provided a helper function that takes the Canvas name and returns a color image. Because the Canny algorithm works on grayscale images, we have to do the extra step at line 3 to invoke\u00c2\u00a0cv.cvtColor \u00c2\u00a0to convert the input image from color to grayscale. Finally, after getting the result of Canny algorithm, we can render the image in the output canvas (line 6).\u00c2\u00a0Figure 5\u00c2\u00a0shows a snapshot of this program running inside a browser.   Figure 4 \u00e2\u0080\u0093 How to apply the Canny algorithm to find the edges in an image     Figure 5 \u00e2\u0080\u0093 Rendering the image in line 6   The next example (Figures 6 \u00c2\u00a0and\u00c2\u00a07 ) uses Haar cascades to detect faces in an image. Because this algorithm works on grayscale images, the input image is converted at line 3. At line 7, we initialize a cascade classifier and load it with a model for detecting faces. Other models trained to detect different objects, such as cats and dogs, can be used as well. At line 9, we invoke\u00c2\u00a0detectMultiscale , which searches in multiple copies of input images scaled with different sizes. When finished, it returns a list of rectangles for possible faces in the image. At line 10, we iterate over those rectangles and use the\u00c2\u00a0cv.rectangle \u00c2\u00a0function to highlight that part of the image.   Figure 6 \u00e2\u0080\u0093 Face detection using cascade classifiers   We\u00e2\u0080\u0099ve seen how to process single images in Web applications using OpenCV.js. Processing video boils down to processing a sequence of individual frames. The next example (Figures 8 \u00c2\u00a0and\u00c2\u00a09 ) demonstrates:  How to capture \u00c2\u00a0frames from a video element How to subtract \u00c2\u00a0background from input video using the MOG2 algorithm How to display \u00c2\u00a0the processed frame on an HTML Canvas  The\u00c2\u00a0cv.VideoCapture \u00c2\u00a0object provided by utils.js enables WebRTC to access and manage camera resources. This examples assumes the input video contains 30 frames per second. So, at every 1/30 of a second, it invokes the\u00c2\u00a0processVideo \u00c2\u00a0function. This function:  Reads \u00c2\u00a0the next video frame (line 18) Applies \u00c2\u00a0background extraction function (line 19) Displays \u00c2\u00a0the output foreground mask (line 20)  Finally, at line 23 the next invocation of the function is scheduled.   Figure 7 \u00e2\u0080\u0093 Subtracting background for different frames of input video using the MOG2 method     Figure 8 \u00e2\u0080\u0093 Rendering the image     Figure 9 \u00e2\u0080\u0093 Capturing a video frame and subtracting the background   The last example (Figures 10 \u00c2\u00a0and\u00c2\u00a011 ) demonstrates using a pre-trained DNN in Web applications. While in this example we use a DNN to recognize objects, they can also be specialized to do other recognition tasks, such as background segmentation. At line 2, the program reads a Caffe framework model of GoogleNet*. Other formats, such as Torch and TensorFlow, are also supported. In the next step, at line 6, we convert the input image into a blob that fits the network. Then, at lines 9 and 10, we forward the blob along the network and find the highest probability class.\u00c2\u00a0Figure 10 \u00c2\u00a0shows a snapshot of the program categorizing a sample image. (You can see more examples of OpenCV.js usage at\u00c2\u00a0https://docs.opencv.org.)   Figure 10 \u00e2\u0080\u0093 Object detection example using GoogLeNet model     Figure 11 \u00e2\u0080\u0093 Using a pre-trained DNN in Web applications   Performance Evaluation  OpenCV.js brings a lot of computer vision capabilities to the Web. To demonstrate their performance, we have selected a number of vision benchmarks including primitive kernels and more sophisticated vision applications including:  Canny\u00e2\u0080\u0099s \u00c2\u00a0algorithm for edge detection Finding faces \u00c2\u00a0using Haar cascades Finding people \u00c2\u00a0using a histogram of gradients  We used a Firefox* browser running on an\u00c2\u00a0Intel\u00ae Core\u2122 i7-3770 processor\u00c2\u00a0with 8GB of RAM with Ubuntu* 16.04 for our setup and ran experiments over sequences of videos. Figure 12 \u00c2\u00a0shows the average speedup of both simple JavaScript kernels and vision applications compared to their native equivalent that use an OpenCV scalar build (i.e., not using parallelism). As you can see, the JavaScript performance is competitive. While we found WASM and asm.js performance to be close, the WASM version of the library is significantly faster to initialize and is more compact. Its size is about 5.3 MB compared to the asm.js version, which is 10.4 MB.   Figure 12 \u00e2\u0080\u0093 Performance evaluation of primitive kernels and vision applications running on Firefox   Making it Even Faster  Computer vision is computationally demanding. A lot of computations need to be performed on a massive number of pixels. For instance, each iteration of the baseline Canny, face, and people benchmarks takes on average 7 ms, 345 ms, and 323 ms, respectively, to process a single 800 x 600 resolution image. While it\u00e2\u0080\u0099s fast to compute Canny, face, and people detection, they are still very expensive and cannot be used in real-time, interactive use-cases. Fortunately, computer vision algorithms are inherently parallel, and good algorithm design and an optimized implementation can lead to significant speedups on parallel hardware. OpenCV comes with parallel implementations of algorithms for different architectures. We take advantage of two methods that target multicore processors and SIMD units to make the JavaScript version faster. We\u00e2\u0080\u0099ve skipped GPU implementations at the moment due to their complexity. The upcoming WebGPU* API can potentially be used to accelerate OpenCV on GPUs. SIMD.js  SIMD.js4, 5 \u00c2\u00a0is a new Web API to expose processor vector capabilities to the Web. It is based on a common subset of the Intel SSE2 and ARM NEON* instruction sets that runs efficiently on both architectures. They define vector instructions that operate on 128-bit-wide vector registers, which can hold four integers, four single-precision floating-point numbers, or 16 characters.\u00c2\u00a0Figure 13 \u00c2\u00a0shows how vector registers can add four integers with one CPU instruction.   Figure 13 \u00e2\u0080\u0093 Scalar versus SIMD for the addition of four integers   SIMD is proven to be very effective in improving performance, especially for multimedia, graphics, and scientific applications.5, 6 \u00c2\u00a0In fact, many OpenCV functions, such as core routines, are already implemented using vector intrinsics. We\u00e2\u0080\u0099ve adapted the work done by Peter Jensen, Ivan Jibaja, Ningxin Hu, Dan Gohman, and John Mc-Cutchan7 \u00c2\u00a0to translate OpenCV vectorized implementations using SSE2 intrinsics into JavaScript with SIMD.js instructions. Inclusion of the SIMD.js implementation will not affect the library interface.\u00c2\u00a0Figure 14 \u00c2\u00a0shows the speedups that are obtained by SIMD.js on selected kernels and applications running on Firefox. Up to 8x speedup is obtained for primitive kernels. As expected, the speedup is higher for smaller data types. There are fewer vectorization opportunities in complex functions such as Canny, face, and people detection. Currently, SIMD.js can only be used in the asm.js context and is supported by the Firefox and Microsoft Edge* browsers. SIMD in WebAssembly is currently planned to have the same specification as SIMD.js. Hence, similar performance numbers are expected.   Figure 14 \u00e2\u0080\u0093 Performance improvement using SIMD.js   Multithreading using Web Workers  JavaScript programs use Web workers for parallel processing of heavy computing tasks. Web workers communicate by message passing, which could incur significant cost, especially when passing large messages such as images.\u00c2\u00a0SharedArrayBuffer 8 \u00c2\u00a0has recently been proposed as a storage system that can be shared between Web workers. They can use it to implement a shared-memory parallel programming model. OpenCV uses its\u00c2\u00a0parallel_for_ \u00c2\u00a0framework to implement multithreaded versions of vision functions. The\u00c2\u00a0parallel_for_  framework can target multiple multithreading models including POSIX* threads (Pthreads). With recent Emscripten* developments, it\u00e2\u0080\u0099s possible to translate the Pthreads. API into equivalent JavaScript using Web workers with shared array buffers. OpenCV.js with multithreading support will use a pool of Web workers and allocate a worker when a new thread is being spawned. Also, it exposes OpenCV APIs to dynamically adjust the concurrency such as changing number of concurrent threads (i.e., cv.SetNumThreads) to JavaScript. To study the performance impact of using multiple Web workers, we measured the performance of three application benchmarks that did not gain significantly from SIMD vectorization using different numbers of workers (up to 8). The OpenCV load balancing algorithm divides the workload evenly among threads. As shown in\u00c2\u00a0Figure 15 , on a processor with eight logical cores, we obtained a 3x to 4x speedup. Note that a similar trend is observed on native Pthreads implementations of the same functions.   Figure 15 \u00e2\u0080\u0093 Speedup achieved using multiple Web workers    Computer Vision for the Masses  "}