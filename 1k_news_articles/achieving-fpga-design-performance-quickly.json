{"Author": "EETimes\u00a0", "Date": "02.08.2017", "Keywords": "", "Article": " Today\u2019s engineering teams are tasked with delivering FPGA-based products under incredible schedule constraints to market windows. Closing timing constraints is still a challenge for many designers. FPGA design tools are a necessity to help define and apply the correct constraints to a design to quickly close timing and complete the project. This blog highlights the broad steps designers need to complete as they close timing and how tool automation helps to simplify the process.  Design setup Initial timing constraint setup Constraints tuning  When starting a new project, designers need to setup the environment and import the IP for the design, which may come from multiple sources. FPGA design tools help automate this process for designers, making it easier and faster while also helping to remove import errors from the process. In addition to the IP import, the tools should automate the constraint import for a given block. These constraints will be shown in the FPGA Design Constraints (FDC) files within the tools, showing the correct syntax for things like clocks, I/O, and clock groups. The FPGA designer will need to complete a first pass synthesis run with the \u201cautoconstrain\u201d option enabled for the new design, which should automatically create constraints for any remaining clocks. The tool also provides a report for the designer to view the initial performance of the design.  In the above example, there were no initial constraints when importing the IP, however the tool inferred three clocks based on the design and setup initial constraints for them. This is an automated way of creating and applying a set of initial constraints for the unconstrained clocks. If other constraints need to be applied to the design, the designer can enter them directly by editing the FDC file(s) or using a graphical constraints editor. With the initial constraints defined, the designer will need to ensure all the clock constraints are correct by running the \u201csyntax check\u201d for the entire design. This syntax check verifies the constraints are defined correctly and any issues will be outlined in the log files for the designer to evaluate and fix quickly. Once the \u201csyntax check\u201d is complete, the next step is to complete the \u201csynthesis check\u201d on the design. This should allow the designer to find and fix any hardware-related errors quickly. The designer is now ready to complete a full synthesis step on the design. \u201cFast synthesis\u201d and \u201ccontinue on error\u201d should be enabled in the tool, which helps to identify all the errors in a single synthesis pass. Once any errors identified by the tools are fixed, the last step is to complete a full constraint check to look for constraint setup issues with clock relationships, missing I/O constraints, and other related issues. Once valid constraints with good syntax have been applied to the design, we can then fine-tune them for the performance requirements of the end-product. By leveraging automation, checkers, and continue-on-error capabilities, designers are able to accelerate the process of defining good quality constraints and applying them to a design. Related posts:  Automating IP Handling in a Multi-Source World Achieving Better Productivity with Faster Synthesis FPGAs & Functional Safety in Industrial Applications FPGA Design: Faster Runtimes & Increased Productivity FPGA Debug in the Modern World Versatile FPGA IP Handling, Creation & Packaging Functional Safety and the FPGA World       Share this:TwitterFacebookLinkedIn "}